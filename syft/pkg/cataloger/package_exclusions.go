package cataloger

import (
	"golang.org/x/exp/slices"

	"github.com/anchore/syft/syft/artifact"
	"github.com/anchore/syft/syft/pkg"
	"github.com/anchore/syft/syft/pkg/cataloger/alpm"
	"github.com/anchore/syft/syft/pkg/cataloger/apkdb"
	"github.com/anchore/syft/syft/pkg/cataloger/binary"
	"github.com/anchore/syft/syft/pkg/cataloger/deb"
	"github.com/anchore/syft/syft/pkg/cataloger/nix"
	"github.com/anchore/syft/syft/pkg/cataloger/rpm"
)

type CategoryType string

const (
	OsCatalogerType     CategoryType = "os"
	BinaryCatalogerType CategoryType = "binary"
)

var CatalogerTypeIndex = map[CategoryType][]string{
	OsCatalogerType: {
		apkdb.CatalogerName,
		alpm.CatalogerName,
		deb.CatalogerName,
		nix.CatalogerName,
		rpm.DBCatalogerName,
		rpm.FileCatalogerName,
	},
	BinaryCatalogerType: {
		binary.CatalogerName,
	},
}

// Exclude will remove packages from a collection given the following properties are true
// 1) the relationship between packages is OwnershipByFileOverlap
// 2) the parent is an "os" package
// 3) the child is a synthetic package generated by the binary cataloger
// 4) the package names are identical
// This exclude was implemented as a way to help resolve: https://github.com/anchore/syft/issues/931
func Exclude(r artifact.Relationship, c *pkg.Collection) bool {
	parent := c.Package(r.From.ID())
	if parent == nil {
		return false
	}
	child := c.Package(r.To.ID())
	if child == nil {
		return false
	}

	if artifact.OwnershipByFileOverlapRelationship != r.Type {
		return false
	}

	parentInExclusion := slices.Contains(CatalogerTypeIndex[OsCatalogerType], parent.FoundBy)
	if !parentInExclusion {
		return false
	}

	return slices.Contains(CatalogerTypeIndex[BinaryCatalogerType], child.FoundBy)
}
