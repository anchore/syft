package executable

import (
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/scylladb/go-set/strset"
)

var goNMTypes = []string{
	"T", // text (code) segment symbol
	"t", // static text segment symbol
	"R", // read-only data segment symbol
	"r", // static read-only data segment symbol
	"D", // data segment symbol
	"d", // static data segment symbol
	"B", // bss segment symbol
	"b", // static bss segment symbol
	"C", // constant address
	"U", // referenced but undefined symbol
}

// validNMTypes returns the list of valid NM types for Go symbols.
func validNMTypes() []string {
	return goNMTypes
}

// isValidNMType checks if the given type is a valid NM type.
func isValidNMType(t string) bool {
	for _, valid := range goNMTypes {
		if t == valid {
			return true
		}
	}
	return false
}

const (
	vendorPrefix         = "vendor/"
	extendedStdlibPrefix = "golang.org/x/"
	typeEqualityPrefix   = "type:.eq."
	gcShapeStencilPrefix = "go.shape."
)

// createGoSymbolFilter creates a filter function for Go symbols based on the provided configuration. This filter function
// returns true if a symbol should be included based on its name and type. This also allows for modification of the symbol name
// if necessary (e.g., normalization of vendored module paths). The returned name is only valid if the boolean is true.
func createGoSymbolFilter(cfg SymbolConfig) func(string, string) (string, bool) {
	validNmTypes := buildNmTypes(cfg.Types)

	return func(symName, symType string) (string, bool) {
		// check if this is a valid type
		if !validNmTypes.Has(symType) {
			return "", false
		}

		// filter out floating point literals and other compiler literals (e.g., $f64.3fceb851eb851eb8)
		if isCompilerLiteral(symName) {
			return "", false
		}

		// filter based on exported/unexported symbol configuration
		exported := isExportedSymbol(symName)
		if !shouldIncludeByExportStatus(exported, cfg.Go.ExportedSymbols, cfg.Go.UnexportedSymbols) {
			return "", false
		}

		// handle type equality functions (e.g., type:.eq.myStruct)
		if isTypeEqualityFunction(symName) {
			if !cfg.Go.TypeEqualityFunctions {
				return "", false
			}
			return symName, true
		}

		// handle GC shape stencil functions (e.g., go.shape.func())
		if isGCShapeStencil(symName) {
			if !cfg.Go.GCShapeStencils {
				return "", false
			}
			return symName, true
		}

		// normalize vendored module paths if configured
		symName = normalizeVendoredPath(symName, cfg.Go.NormalizeVendoredModules)

		// determine the package path for classification
		pkgPath := extractPackagePath(symName)

		// handle extended stdlib (golang.org/x/*)
		if isExtendedStdlib(pkgPath) {
			if !cfg.Go.ExtendedStandardLibrary {
				return "", false
			}
			return symName, true
		}

		// handle stdlib packages
		if isStdlibPackage(pkgPath) {
			if !cfg.Go.StandardLibrary {
				return "", false
			}
			return symName, true
		}

		// this is a third-party package
		if !cfg.Go.ThirdPartyModules {
			return "", false
		}
		return symName, true
	}
}

// buildNmTypes creates a set of valid NM types from the configuration.
// If no types are specified, all default types are used.
func buildNmTypes(types []string) *strset.Set {
	tys := strset.New(types...)
	if tys.Size() == 0 {
		return strset.New(goNMTypes...)
	}

	// only allow valid nm types to continue...
	return strset.Intersection(strset.New(goNMTypes...), tys)
}

// isCompilerLiteral checks if a symbol is literal symbol inserted by the compiler.
// This includes floating point literals, int constants, and others.
// These have the format: $f64.3fceb851eb851eb8 or $f32.3f800000
// where the hex represents the IEEE 754 representation of the value.
func isCompilerLiteral(symName string) bool {
	return strings.HasPrefix(symName, "$")
}

// shouldIncludeByExportStatus determines if a symbol should be included based on its
// export status and the configuration settings for exported/unexported symbols.
func shouldIncludeByExportStatus(exported, includeExported, includeUnexported bool) bool {
	if exported && !includeExported {
		return false
	}
	if !exported && !includeUnexported {
		return false
	}
	return true
}

// isTypeEqualityFunction checks if a symbol is a compiler-generated type equality function.
// These are automatically generated by the Go compiler for generic types
// and have the format: type:.eq.TypeName
func isTypeEqualityFunction(symName string) bool {
	return strings.HasPrefix(symName, typeEqualityPrefix)
}

// isGCShapeStencil checks if a symbol is a GC shape stencil function.
// These are related to how generics are implemented and are not user defined or directly callable.
// They can appear as a prefix (e.g., "go.shape.func()") or within generic type parameters
// (e.g., "slices.partitionCmpFunc[go.shape.struct { ... }]").
func isGCShapeStencil(symName string) bool {
	// check for prefix: go.shape.*
	if strings.HasPrefix(symName, gcShapeStencilPrefix) {
		return true
	}
	// check for embedded in generic type parameter: [go.shape.*
	return strings.Contains(symName, "["+gcShapeStencilPrefix)
}

// normalizeVendoredPath removes the "vendor/" prefix from vendored module paths if normalization is enabled.
func normalizeVendoredPath(symName string, normalize bool) string {
	if normalize && isVendoredPath(symName) {
		return strings.TrimPrefix(symName, vendorPrefix)
	}
	return symName
}

// isVendoredPath checks if a symbol name represents a vendored module path.
func isVendoredPath(symName string) bool {
	return strings.HasPrefix(symName, vendorPrefix)
}

// isExtendedStdlib checks if a package path is part of the Go extended standard library (golang.org/x/*).
func isExtendedStdlib(pkgPath string) bool {
	return strings.HasPrefix(pkgPath, extendedStdlibPrefix)
}

// extractPackagePath extracts the package import path from a symbol name.
// For example, "github.com/foo/bar.Baz" returns "github.com/foo/bar".
func extractPackagePath(symName string) string {
	lastDot := strings.LastIndex(symName, ".")
	if lastDot == -1 {
		return symName
	}
	return symName[:lastDot]
}

// isExportedSymbol checks if a symbol is exported (public) by examining if the first
// character of the symbol name (after the last '.') is uppercase.
func isExportedSymbol(symName string) bool {
	lastDot := strings.LastIndex(symName, ".")
	if lastDot == -1 || lastDot >= len(symName)-1 {
		return false
	}
	firstRune, _ := utf8.DecodeRuneInString(symName[lastDot+1:])
	return unicode.IsUpper(firstRune)
}

// isStdlibPackage determines if a package path represents a Go standard library package.
// Stdlib packages don't contain a '.' in their path (they use simple names like "fmt", "net/http").
// Third-party packages start with a domain containing a '.' (e.g., "github.com", "golang.org").
func isStdlibPackage(pkgPath string) bool {
	// the "main" package is treated as stdlib for our purposes
	if pkgPath == "main" {
		return true
	}
	// stdlib packages don't contain dots in their import path
	return !strings.Contains(pkgPath, ".")
}
